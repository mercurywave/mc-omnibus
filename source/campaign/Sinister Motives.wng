
using Slide
using Campaign


data : dim $Campaign.Create("Sinister Motives", $Img.SinisterMotives)
    mixin $Campaign.mixOfficalCampaign(4)
    mixin $mixTooltipGen(`$SinMo.TooltipGen(state, player)`)
    
    mixin $mixProductInfo(dim)
        "Sinister Motives expansion"

    mixin $mixSaveGameReminder()

    mixin $mixHeroSelection()

    mixin $mixSlides(dim)
        $Slide.Popup("Note", textdata)
            You may not include the following cards in your player decks 
            unless a campaign rule states otherwise:
            * Venom (Eddie Brock)
            * Symbiote Suit

    mixin $mixModeSelect()
    
    mixin $mixSlides(dim)
        $IfExpert($Slide.Popup("Expert Campaign", textdata))
            **Optionally** as an additional challenge, you may choose to restrict 
            your deckbuilding for the expert campaign.
            
            After building your deck for the expert campaign, you cannot add, remove, or 
            change the aspect and/or basic cards in you deck for the remainder of the campaign.
            However, campaign-specific cards can be added to you deck as per the campaign rules.

            This app does not currently track your deck for this option,
            so you will have to do so using an external tool.

    //////////// MISSION 1 ////////////
    mixin $mixMission("S0", 1, "City in Chaos", $Img.Sandman, dim
            _ , $g.BackStyle.Black, $g.LineStyle.Yellow, $g.ForeStyle.Orange
            _ , "Read page 7-8 from the Sinister Motives rule book")
        
        $CheckList("Setup", dim, null, $Img.Sandman)
            $EnemyStageCheck("Sandman")
            $CheckList.MakeCheck("**Main Scheme Deck**: Hapless Pedestrians")

        $CheckList("Setup", dim, "**Encounter Deck**", $Img.SandClone)
            $CheckList.MakeCheck("Sandman set")
            $CheckList.MakeCheck("City in Chaos")
            $CheckList.MakeCheck("Down to Earth")
            $CheckList.MakeCheck("Standard set")
            $ExpertEncounterSetCheck()

        $SinMo.PublicOutcry()
        
        $SinMo.CommunityService(1)

        $IfExpert($CheckList("Expert Setup", dim, "", $Img.CityStreets))
            $CheckList.MakeCheck("Place 2 additional sand counters on the City Streets environment")
            $CheckList.MakeCheck("Resolve the \"Surging Sands\" ability of the City Streets environment")

        $PlayGame()

        $IfExpert($RecordHP())
        $SinMo.CommunityServiceComplete()
    
    mixin $SinMo.Reputation.mixMissionEnd(1)
    mixin $Campaign.mixSlides(dim)

        $PlayGame()

library SinMo
    library Const
        $ComServ : "community service"
        $LastComServ : "current community service"
        $Rep : "reputation"
        $Mission : "mission"
        $Victory : "victory points"
        $NoMinions : "no minions"
        $NoSideSchemes : "no side schemes"
        $NoMainThreat : "no threat"
        $NoAccel : "no acceleration"
        $NoDefeated : "no defeats"
        $ShieldTech : "shield tech"
        $OsbornTech : "osborn tech"

    ::TooltipGen(state, player => tooltip)

    ::PublicOutcry(=> slide)
        return $Slide.CheckList("Bad Publicity", dim, "From the Bad Publicity campaign set:", $Img.PublicOutcry)
            $CheckList.MakeCheck($GT(textdata), `!stage.state.$Campaign.State.IsExpert()`)
                Put the Public Outcry environment into play <br>
                <i>(Use the side with the text "Standard Mode Only")</i>
            $CheckList.MakeCheck($GT(textdata), `stage.state.$Campaign.State.IsExpert()`)
                Put the Public Outcry environment into play <br>
                <i>(Use the side with the text "Expert Mode Only")</i>
            $CheckList.MakeCheck("Shuffle the Smear Campaign treachery card into the encounter deck")

    ::CommunityService(mission => slide)
        @text1 : "Choose a \"Campaign - Community Service\" side scheme at random"
        @text2 : "Shuffle that side scheme card into the encounter deck"
        return $GetAnotherComServ(mission, "Community Service", text1, text2, $GTA(textdata))
            Back Alley Burglary
            Cat in a Tree
            Henchmen Heist
            Off the Rails
            Rubble Rescue

    ::GetAnotherComServ(mission, title, text1, text2, &possibleCards => slide)
        return $Slide.Create(lambda(stage => async)[mission, title, text1, text2, free possibleCards])
            
            @unpicked : possibleCards.$List.Filter(`!stage.state[$Const.ComServ, it] ? false`)
            @initial : stage.ghost[$Const.LastComServ] ? possibleCards.$List.QuickPick()

            @pick : await $DoGetAnotherNewFromPile(stage, title, text1, text2, unpicked, initial)

            stage.delta[$Const.LastComServ] : pick ? ""


    ::DoGetAnotherNewFromPile(stage, title, text1, text2, possibleCards, initial => async selection)
        using Dom
        @pipe : stage.ct.$Canceler.MakePipe()
        
        @drop
        @pop : dim $Popup.Create(title)
            mixin $Style.AddClasses("getFromPile")
            mixin $Popup.AddMarkdown(text1)
            mixin $AppendChild(dim $Dropdown.Create() >> drop)
                mixin $Dropdown.AddListOfOptions(possibleCards)
                mixin $Dropdown.SetValue(initial)
            mixin $Popup.AddMarkdown(text2)

        pop.$Popup.AddBotRightButton(lambda)
            pipe.$Pipe.Kill()

        $Slide.HookAdvance(stage, lambda)
            pipe.$Pipe.Kill()

        await pipe.$Pipe.ReadAsync()

        if stage.ct.$Canceler.IsLive()
            selection : drop.$Dropdown.GetValue()

    ::CommunityServiceComplete(=> slide)
        => $Slide.Create(lambda(stage => async))
            using Fork
            @service : stage.state[$Const.LastComServ]
            @text : "Is the " + service + " side scheme in the victory display?"
            @opts : dim
                $MakeOption(service + " in victory display", true)
                $MakeOption("Not in victory display", false)
            @preSelect : stage.ghost[$Const.ComServ, service] ? false
            await $DoForkThen(stage, lambda(pick), "Victory", text, opts, preSelect)
                if pick
                    stage.delta[$Const.ComServ, service] : true

    library Reputation
        ::.mixMissionEnd(mission)
            this.$Campaign.mixSlides(dim)
                $MakeCalculateSlide(mission)
                $IfPassing(1, $DistributeShieldTech())
                $IfPassing(1, $OsTech(mission))

        ::.mixMissionSetup(mission)
            this.$Campaign.mixSlides(dim)
                $IfPassing(1, $OsTech(mission))

        ::IfPassing(value, &subSlide => slide)
            => $Slide.If(`$IsPassing(state, value)`, free subSlide)
            
        ::IfGreater(value, &subSlide => slide)
            => $Slide.If(`$IsGreater(state, value)`, free subSlide)
        
        ::IsPassing(state, value => bool)
            using Const
            @lastMission : state[$Mission].$Obj.PrevKey()
            @score : $CalcCurr(state)
            if score >= value
                @delta : $CalcForMission(state, lastMission)
                if score - delta < value
                    return true
            return false
        
        ::IsGreater(state, value => bool)
            => $CalcCurr(state) >= value

        ::CalcCurr(state => val)
            val : 0
            using Const
            for @miss in state[$Mission]
                val +: $CalcForMission(state, miss)

        ::CalcForMission(state, mission => val)
            val : 0
            using Const
            state[$Mission, mission, $Const.Victory] ? 0
                for @key of dim($NoMinions, $NoSideSchemes, $NoMainThreat, $NoAccel, $NoDefeated)
                    if state[$Mission, mission, key] ? false
                        val +: 1

        ::MakeCalculateSlide(mission => slide)
            => $Slide.Create(lambda(stage => async))
                    await $DoCalculateSlide(stage, mission)

        ::DoCalculateSlide(stage, mission => async)
            using Dom
            @pipe : stage.ct.$Canceler.MakePipe()

            @ghost : stage.ghost[$Const.Mission, mission] ? dim()
            @commServiceVal : switch
                stage.state[$Const.ComServ, stage.state[$Const.LastComServ]] ? false : 1
                else : 0
            @initVic : ghost[$Const.Victory] ? commServiceVal
            @isExpert : stage.state.$State.IsExpert()

            @vicCtl; @pane
            
            @pop : dim $Popup.Create("Conditions")
                mixin $Style.AddClasses("conditions")
                mixin $AppendChild(dim $Div.Create())
                    mixin $Style.AddClasses("scroller")
                    mixin $Popup.AddMarkdown($GTW(textdata))
                        Enter Victory points and mark each condition met at the end of
                        the game to calculate your reputation score for the mission
                    
                    //mixin $AppendChild(dim $Div.Create())
                        //mixin $Style.AddClasses("numPane")
                    mixin $AppendChild(dim $Input.CreateLabelFor("txtVic"))
                        mixin $AppendChild(dim $NumberEntry.Create() >> vicCtl)
                            mixin $Style.AddClasses("numberEntry")
                            mixin $NumberEntry.SetText(initVic)
                            mixin $NumberEntry.DoSelectAllOnFocus()
                            mixin $SetId("txtVic")
                        mixin $AppendChild($Paragraph.Create("Victory points in the victory display"))

                    mixin $AppendChild(dim $Div.Create() >> pane)

                mixin $Popup.AddBotRightButton(`pipe.$Pipe.Kill()`)
            $Slide.HookAdvance(stage, `pipe.$Pipe.Kill()`)
            
            @chkMinions : pane.$mixAddCheckBox("No minions in play (+1)", ghost[$Const.NoMinions] ? false)
            @chkSide : pane.$mixAddCheckBox("No side schemes in play (+1)", ghost[$Const.NoSideSchemes] ? false)
            @chkMain : pane.$mixAddCheckBox("No threat on the main scheme (+1)", ghost[$Const.NoMainThreat] ? false)
            @chkAccel : pane.$mixAddCheckBox(
                _ "Fewer than " + stage.state.players + " acceleration tokens in play (+1)"
                _ , ghost[$Const.NoAccel] ? false)
            @anyDefeat : switch
                isExpert : stage.state.$State.AnyPlayerDefeated()
                else : ghost[$Const.NoDefeated] ? false
            @chkDefeat : pane.$mixAddCheckBox("No defeated players (+1)", !anyDefeat, isExpert)

            await pipe.$Pipe.ReadAsync()
            if stage.ct.$Canceler.IsLive()
                using Const
                (stage.delta[$Mission, mission], @node) : dim()
                node[$Const.Victory] : vicCtl.$NumberEntry.GetText()
                node[$Const.NoMinions] : chkMinions.$Checkbox.IsChecked()
                node[$Const.NoSideSchemes] : chkSide.$Checkbox.IsChecked()
                node[$Const.NoMainThreat] : chkMain.$Checkbox.IsChecked()
                node[$Const.NoAccel] : chkAccel.$Checkbox.IsChecked()
                node[$Const.NoDefeated] : chkDefeat.$Checkbox.IsChecked() 
        
        ::DistributeShieldTech(=> slide)
            => $Slide.Create(lambda(stage => async))
                    @text : $GTW(textdata)
                        Deal 3 "Campaign - S.H.I.E.L.D. Tech" upgrades at random to each 
                        player. Each player may choose 1 to add to their deck for the 
                        rest of the campaign.<br/>
                        <em>(These do not count toward minimum/maximum deck size)</em>
                    await $RedSkull.DoDistributeVictory(stage, $Const.ShieldTech, text, $GTA(textdata), "Reputation")
                        Compact Darts
                        Impact-Dampening Suit
                        Laser Googles
                        Propulsion Gauntlet
                        Retinal Display
                        Shock Knuckles
                        Wave Bracers
                        Wrist Navigators

        ::LogAnotherFromPile(key, title, text1, text2, &possibleCards => slide)
            return $Slide.Create(lambda(stage => async)[key, title, text1, text2, free possibleCards])
                
                @unpicked : possibleCards.$List.Filter(`!stage.state[key, it] ? false`)
                @initial : stage.ghost[key]?.$Obj.NextKey() ? possibleCards.$List.QuickPick()

                @pick : await $DoGetAnotherNewFromPile(stage, title, text1, text2, unpicked, initial)

                if pick != null & pick != ""
                    stage.delta[key, pick] : true

        ::OsTech(mission => slide)
            @text1 : "Choose one \"Osborn Tech\" attachment at random"
            return $LogAnotherFromPile($Const.OsbornTech, "Reputation", text1, "",  $GTA(textdata))
                Arm Cannon
                Ionic Boots
                Kinetic Armor
                Neocarbon Scales
                Spiked Gauntlet
                Tracking Display
        
        ::OsTechSetup(=> slide)
            => $Slide.Create(lambda(stage => async))
                @opts : dim()
                for @card in stage.state[$Const.OsbornTech]
                    opts.$List.Add($CheckList.MakeCheck(card))
                @text : "Shuffle each of the following Osborn Tech cards into the encounter deck"
                await $CheckList.DoChecklist(stage, "Reputation", text, opts, null, false)
                
                

scratch _uniqChkID : 0
::.mixAddCheckBox(label, ?isChecked, ?disable => chk)
    using Dom
    ^_uniqChkID +: 1
    @id : "chkUniq" + ^_uniqChkID
    this.$AppendChild(dim $Checkbox.CreateLabelFor(id))
        mixin $AppendChild(dim $Checkbox.Create() >> chk)
            mixin $SetId(id)
            mixin $Checkbox.SetIsChecked(isChecked ? false)
        mixin $Style.SetClassIf("disabled", disable ? false)
        mixin $AppendChild($Paragraph.Create(label))
    if disable
        chk.$SetAttribute("disabled", "disabled")

